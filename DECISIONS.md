# Архитектурные и технические решения

## Общая философия
Главным приоритетом при разработке была реализация рабочего решения в минимально возможные сроки при строгом соблюдении требований ТЗ. Архитектура построена по принципам KISS и DRY: избегалось преждевременное усложнение, не вводились абстракции без явной необходимости. Проект остался в виде одного исполняемого файла (`main.py`), что упрощает запуск, отладку и проверку.

## Выбор инструментов

### YOLOv8 (ultralytics)
Выбрана предобученная модель `yolov8n.pt` по следующим причинам:
- Доступна «из коробки» через библиотеку `ultralytics`;
- Поддерживает детекцию людей (класс 0) с достаточной точностью даже на небольших разрешениях;
- Работает как на CPU, так и на GPU без изменений в коде;
- Имеет простой API, не требует подготовки данных или дообучения;
- Является проверенным решением для задач real-time детекции.

Отказ от более тяжёлых моделей (например, yolov8m/x) обусловлен требованием простоты и допустимостью работы на CPU.

### OpenCV
Использован для:
- Захвата и воспроизведения видео;
- Рисования графических примитивов (зоны, bounding boxes, текст);
- Геометрических проверок (`pointPolygonTest` для определения попадания точки в полигон).

OpenCV выбран как де-факто стандарт для CV-задач в Python, с хорошей документацией и предсказуемым поведением.

### Формат хранения зон — JSON
Координаты запрещённых зон сохраняются в `restricted_zones.json`, потому что:
- Формат человекочитаем и легко редактируется вручную при необходимости;
- Не требует дополнительных зависимостей (встроенная библиотека `json`);
- Поддерживает произвольное число зон и произвольную форму (полигоны);
- Соответствует требованию ТЗ о сохранении в файл.

## Архитектура проекта

### Единый файл (`main.py`)
Отказ от разделения на модули (`utils/`, `detectors/`, `config.py`) принят сознательно:
- Объём логики не превышает 200 строк рабочего кода;
- Разделение в данном случае не добавляет ценности, а лишь усложняет навигацию;
- ТЗ прямо указывает на «простую реализацию без усложнений» — однофайловое решение этому соответствует;
- Упрощает проверку: достаточно запустить `python main.py`.

Все вспомогательные функции (`point_in_polygon`, `setup_restricted_zones`) помещены в один файл с основной логикой. Это не нарушает DRY, так как каждая функция используется ровно по назначению, без дублирования.

### Логика детекции и проверки
- В качестве точки для проверки проникновения используется центр bounding box (`(x1+x2)//2, (y1+y2)//2`);
- Это обеспечивает баланс между точностью и производительностью;
- Проверка выполняется для каждого детектированного человека по всем зонам;
- Использование `cv2.pointPolygonTest` гарантирует корректную работу с произвольными невыпуклыми полигонами.

### Механизм тревоги
- Тревога активируется мгновенно при обнаружении любого человека в зоне;
- Деактивация происходит не сразу, а через 3 секунды после того, как в зоне никого не осталось;
- Такой подход предотвращает мерцание сигнала при кратковременном исчезновении объекта (например, из-за нестабильности детекции);
- Таймаут реализован через `time.time()`, что не зависит от FPS и устойчиво к пропуску кадров.

### Интерактивная разметка
- Запускается автоматически при отсутствии `restricted_zones.json`;
- Реализована через `cv2.setMouseCallback`, что соответствует требованию «разметка поверх кадра»;
- Сохранение происходит по нажатию `s`, отмена — по `q`;
- Координаты замыкаются автоматически (добавляется первая точка в конец, если не замкнуты).

Этот подход позволяет гибко задавать зоны под любое видео без изменения кода.

## Отказ от DeepSORT
В текущей реализации трекинг не используется, хотя в ТЗ он указан как «плюс». Решение принято по следующим причинам:
- ТЗ требует «простой реализации без усложнений»;
- DeepSORT добавляет зависимости (`scipy`, `filterpy`), усложняет установку и отладку;
- Для базовой задачи детекции проникновения трекинг не обязателен: достаточно одного кадра с детекцией в зоне;
- При необходимости интеграция DeepSORT возможна в будущем — архитектура допускает замену детектора на трекер без переписывания логики зон и тревоги.

## Переносимость и совместимость
- Код протестирован на Python 3.11;
- Не используются системно-зависимые вызовы;
- Работает на Windows/Linux/macOS при наличии `opencv-python` с GUI-поддержкой;
- GPU используется автоматически, если доступен (проверка через `cv2.cuda.getCudaEnabledDeviceCount()`).

## Выводы
Решение сфокусировано на выполнении всех обязательных пунктов ТЗ с минимальными ресурсами. Оно рабочее, легко запускается, не содержит «мёртвого» кода и может быть расширено при необходимости без переписывания ядра.